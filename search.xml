<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于ETH（以太坊）搭建私有链（Window 10）]]></title>
    <url>%2F2018%2F03%2F07%2F%E5%9F%BA%E4%BA%8EETH%EF%BC%88%E4%BB%A5%E5%A4%AA%E5%9D%8A%EF%BC%89%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E9%93%BE%EF%BC%88Window-10%EF%BC%89%2F</url>
    <content type="text"><![CDATA[引言大家看关于区块链技术的文章和书籍看累了吗，实践出真知。接下来跟小冷一起探索以下怎样搭建基于以太坊的私有链吧，据说ETH对Linux支持是最友好的，但是Window下也没什么问题。 准备工作 以太坊go客户端 传送门 以太坊钱包传送门（等启动私有链节点时才安装） Git客户端（也可在dos窗口） 配置创世区块json文件a. 创建一个genesis.json文件放在Geth文件夹，内容如下1234567891011121314151617&#123; "config": &#123; "chainId": 10, "homesteadBlock": 0, "eip155Block": 0, "eip158Block": 0 &#125;, "alloc" : &#123;&#125;, "coinbase" : "0x0000000000000000000000000000000000000000", "difficulty" : "0x02000000", "extraData" : "lengzi.me", "gasLimit" : "0x2fefd8", "nonce" : "0x0000000000000042", "mixhash" : "0x0000000000000000000000000000000000000000000000000000000000000000", "parentHash" : "0x0000000000000000000000000000000000000000000000000000000000000000", "timestamp" : "0x00"&#125; b. 创世文件参数介绍 参数名 含义 config.chainId 区块链的ID，在 geth 命令中的 –networkid 参数需要与 chainId 的值一致 config.homesteadBlock 硬分叉区块高度 config.eip155Block 硬分叉高度 config.eip158Block 硬分叉高度 coinbase 矿工账号，第一个区块挖出后将给这个矿工账号发送奖励的以太币 difficulty 难度值，越大越难 extraData 附加信息 gasLimit gas 的消耗总量限制，用来限制区块能包含的交易信息总和 nonce 一个 64 位随机数 mixhash nonce 配合用于挖矿，由上一个区块的一部分生成的 hash parentHash 上一个区块的 hash 值 alloc 预设账号以及账号的以太币数量，私有链挖矿比较容易可以不配置 初始化创世区块a. git客户端下输入初始化命令1$ geth -datadir "%cd%\chain" init genesis.json b. 响应结果 12345678[03-07|11:05:45] Allocated cache and file handles database="E:\\Pro gram Files\\Geth\\%cd%\\chain\\geth\\chaindata" cache=16 handles=16INFO [03-07|11:05:46] Writing custom genesis blockINFO [03-07|11:05:46] Persisted trie from memory database nodes=0 size=0.00 B time=0s gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00BINFO [03-07|11:05:46] Successfully wrote genesis state database=chaindat a hash=bf2891…ad1419INFO [03-07|11:05:46] Allocated cache and file handles database="E:\\Pro gram Files\\Geth\\%cd%\\chain\\geth\\lightchaindata" cache=16 handles=16INFO [03-07|11:05:46] Writing custom genesis blockINFO [03-07|11:05:46] Persisted trie from memory database nodes=0 size=0.00 B time=0s gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00BINFO [03-07|11:05:46] Successfully wrote genesis state database=lightcha indata hash=bf2891…ad1419 创建私有链主账号a. 打开Geth控制台 命令行 1$ geth -datadir "%cd%\chain" console 响应结果 123456789101112131415161718192021INFO [03-07|11:14:38] Maximum peer count ETH=25 LES=0 total=25INFO [03-07|11:14:38] Starting peer-to-peer node instance=Geth/v1.8.1-stable-1e67410e/windows-amd64/go1.9.2INFO [03-07|11:14:38] Allocated cache and file handles database="E:\\Program Files\\Geth\\%cd%\\chain\\geth\\chaindata" cache=768 handles=1024WARN [03-07|11:14:38] Upgrading database to use lookup entriesINFO [03-07|11:14:38] Database deduplication successful deduped=0INFO [03-07|11:14:38] Initialised chain configuration config="&#123;ChainID: 10 Homestead: 0 DAO: &lt;nil&gt; DAOSupport: false EIP150: &lt;nil&gt; EIP155: 0 EIP158: 0 Byzantium: &lt;nil&gt; Engine: unknown&#125;"INFO [03-07|11:14:38] Disk storage enabled for ethash caches dir="E:\\Program Files\\Geth\\%cd%\\chain\\geth\\ethash" count=3INFO [03-07|11:14:38] Disk storage enabled for ethash DAGs dir=C:\\Users\\admin\\AppData\\Ethash count=2INFO [03-07|11:14:38] Initialising Ethereum protocol versions="[63 62]" network=1INFO [03-07|11:14:38] Loaded most recent local header number=0 hash=bf2891…ad1419 td=33554432INFO [03-07|11:14:38] Loaded most recent local full block number=0 hash=bf2891…ad1419 td=33554432INFO [03-07|11:14:38] Loaded most recent local fast block number=0 hash=bf2891…ad1419 td=33554432INFO [03-07|11:14:38] Regenerated local transaction journal transactions=0 accounts=0INFO [03-07|11:14:38] Starting P2P networkingINFO [03-07|11:14:40] UDP listener up self=enode://8096441162deac09f26e704c1df61be6f67d2a4d60772b3c0f5be833f1e6ff07e096939cab2704d9e5099326ba77fad3e2ca20364b868cdd88f909e5cf789677@[::]:30303INFO [03-07|11:14:40] RLPx listener up self=enode://8096441162deac09f26e704c1df61be6f67d2a4d60772b3c0f5be833f1e6ff07e096939cab2704d9e5099326ba77fad3e2ca20364b868cdd88f909e5cf789677@[::]:30303INFO [03-07|11:14:40] IPC endpoint opened url=\\\\.\\pipe\\geth.ipcWelcome to the Geth JavaScript console!instance: Geth/v1.8.1-stable-1e67410e/windows-amd64/go1.9.2 modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0 b. 创建主用户并设置密码 命令行 1$ geth -datadir "%cd%\chain" console 响应结果 1234567!! Unsupported terminal, password will be echoed.Passphrase: 123456Repeat passphrase: 123456"0x6483f89d648a16af39f7e8198443df5b5d402805"&gt; INFO [03-07|11:22:38] Etherbase automatically configured address=0x6483F89d648a16AF39F7e8198443df5B5d402805 启动私有链节点a. 开启私有链节点 命令行 1$ geth -targetgaslimit 4294967295 -rpc -rpcaddr "192.168.1.100" -rpcport "8101" -port "30301" -rpcapi "eth,web3,personal" -networkid 2018 -identity 2018 -nodiscover -maxpeers 5 -datadir "%cd%\chain" -unlock 0 -rpccorsdomain "*" -mine console 响应结果 12345678910111213141516171819202122232425262728293031323334353637383940INFO [03-07|11:30:53] Maximum peer count ETH=5 LES=0 total=5INFO [03-07|11:30:54] Starting peer-to-peer node instance=Geth/2018/v1.8.1-stable-1e6 7410e/windows-amd64/go1.9.2INFO [03-07|11:30:54] Allocated cache and file handles database="E:\\Program Files\\Geth\\% cd%\\chain\\geth\\chaindata" cache=768 handles=1024INFO [03-07|11:30:54] Initialised chain configuration config="&#123;ChainID: 10 Homestead: 0 DA O: &lt;nil&gt; DAOSupport: false EIP150: &lt;nil&gt; EIP155: 0 EIP158: 0 Byzantium: &lt;nil&gt; Engine: unknown&#125;"INFO [03-07|11:30:54] Disk storage enabled for ethash caches dir="E:\\Program Files\\Geth\\%cd%\\ chain\\geth\\ethash" count=3INFO [03-07|11:30:54] Disk storage enabled for ethash DAGs dir=C:\\Users\\admin\\AppData\\Ethas h count=2INFO [03-07|11:30:54] Initialising Ethereum protocol versions="[63 62]" network=2018INFO [03-07|11:30:54] Loaded most recent local header number=0 hash=bf2891…ad1419 td=33554 432INFO [03-07|11:30:54] Loaded most recent local full block number=0 hash=bf2891…ad1419 td=33554 432INFO [03-07|11:30:54] Loaded most recent local fast block number=0 hash=bf2891…ad1419 td=33554 432INFO [03-07|11:30:54] Loaded local transaction journal transactions=0 dropped=0INFO [03-07|11:30:54] Regenerated local transaction journal transactions=0 accounts=0INFO [03-07|11:30:54] Starting P2P networkingINFO [03-07|11:30:54] RLPx listener up self="enode://8096441162deac09f26e70 4c1df61be6f67d2a4d60772b3c0f5be833f1e6ff07e096939cab2704d9e5099326ba77fad3e2ca20364b868cdd88f909e5c f789677@[::]:30301?discport=0"INFO [03-07|11:30:54] HTTP endpoint opened url=http://192.168.1.100:8101 cors=* vhosts=localhostWARN [03-07|11:30:54] -------------------------------------------------------------------WARN [03-07|11:30:54] Referring to accounts by order in the keystore folder is dangerous!WARN [03-07|11:30:54] This functionality is deprecated and will be removed in the future!WARN [03-07|11:30:54] Please use explicit addresses! (can search via `geth account list`)WARN [03-07|11:30:54] -------------------------------------------------------------------Unlocking account 0 | Attempt 1/3!! Unsupported terminal, password will be echoed.Passphrase: INFO [03-07|11:30:54] IPC endpoint opened url=\\\\.\\pipe\\geth.ip cUnlocking account 0 | Attempt 2/3Passphrase: 123456(手动输入刚才设置的密码)INFO [03-07|11:31:37] Unlocked account address=0x6483F89d648a16AF39F7e81984 43df5B5d402805INFO [03-07|11:31:37] Transaction pool price threshold updated price=18000000000INFO [03-07|11:31:37] Etherbase automatically configured address=0x6483F89d648a16AF39F7e81984 43df5B5d402805INFO [03-07|11:31:37] Starting mining operationINFO [03-07|11:31:37] Commit new mining work number=1 txs=0 uncles=0 elapsed=0sWelcome to the Geth JavaScript console!instance: Geth/2018/v1.8.1-stable-1e67410e/windows-amd64/go1.9.2coinbase: 0x6483f89d648a16af39f7e8198443df5b5d402805at block: 0 (Thu, 01 Jan 1970 08:00:00 CST) datadir: E:\Program Files\Geth\%cd%\chain modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0 开启自动挖矿模式12345678910111213141516INFO [03-07|13:52:29] Successfully sealed new block number=82 hash=5f3b8b…016c4aINFO [03-07|13:52:29] 🔗 block reached canonical chain number=77 hash=e50543…17be08INFO [03-07|13:52:29] 🔨 mined potential block number=82 hash=5f3b8b…016c4aINFO [03-07|13:52:29] Commit new mining work number=83 txs=0 uncles=0 elapsed=501.4µsINFO [03-07|13:52:30] Successfully sealed new block number=83 hash=ca0e74…b4c1b8INFO [03-07|13:52:30] 🔗 block reached canonical chain number=78 hash=d79fee…65e27bINFO [03-07|13:52:30] 🔨 mined potential block number=83 hash=ca0e74…b4c1b8INFO [03-07|13:52:30] Commit new mining work number=84 txs=0 uncles=0 elapsed=0sINFO [03-07|13:52:30] Successfully sealed new block number=84 hash=97e4ce…aadb11INFO [03-07|13:52:30] 🔗 block reached canonical chain number=79 hash=d6378c…dfe012INFO [03-07|13:52:30] 🔨 mined potential block number=84 hash=97e4ce…aadb11INFO [03-07|13:52:30] Commit new mining work number=85 txs=0 uncles=0 elapsed=500.6µsINFO [03-07|13:52:34] Successfully sealed new block number=85 hash=5f8afd…339017INFO [03-07|13:52:34] 🔗 block reached canonical chain number=80 hash=d3540e…2c1c94INFO [03-07|13:52:34] 🔨 mined potential block number=85 hash=5f8afd…339017INFO [03-07|13:52:34] Commit new mining work number=86 txs=0 uncles=0 elapsed=0 注意：在光标闪烁处等待挖矿 打开ETH钱包查看挖矿结果 打开ETH钱包的exe程序 启动图如下图 注意打开钱包启动页面是图一不是图二 查看钱包内所挖出来的ETH 如下图 在钱包内可进行转账操作 注意：如果要想转账确认需要在 Geth操作台内启动挖矿指令(miner.start())才能确认交易 操作台常用指令 查询所有以太坊账户 1&gt; personal.listAccounts 查看以太坊账户余额 1&gt; eth.getBalance(eth.accounts[1]) 开始挖矿 1&gt; miner.start() 停止挖矿 1&gt; miner.stop() 指令参数解释 参数名 含义 targetgaslimit 每个块的gas上限 rpc 启动rpc通信，可以进行智能合约的部署和调试 rpcaddr rpc接口的地址 rpcport rpc接口的端口号 port 网络监听端口，用于节点之间通信 rpcapi 设置rpc的范围，暂时开启eth,web3,personal足够 networkid 每个块的gas上限 targetgaslimit 设置当前区块链的网络ID nodiscover 禁止被网络中其它节点发现，需要手动添加该节点到网络 maxpeers 最大节点数量 datadir 设置当前区块链网络数据存放的位置 unlock 解锁某用户（此处用用户坐标来控制，解锁后的用户调用接口发起交易时，不要需要提供密码） rpccorsdomain 设置当前区块链网络数据存放的位置 console 启动命令行模式 引用 从0开始搭建基于以太坊的区块链开发环境 轻松搭建以太坊私有链 github ETH源码]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>ETH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《区块链之学习规划》]]></title>
    <url>%2F2018%2F02%2F26%2F%E3%80%8A%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B9%8B%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92%E3%80%8B%2F</url>
    <content type="text"><![CDATA[一个男人最恐怖的噩梦就是，隔壁老王一夜暴富。——巴菲特 2017年最火的莫过于比特币价格上涨的成百上千倍，以致于各种ICO代币纷涌而至。而区块链技术正是从BTC中抽取的一种技术，我大概看了一些相关书籍，什么智能合约、挖矿、公链、私有链、区块链2.0、验证隔离等新名词像一盘散沙令人头晕目眩。目前看来你通别人讲区块链就如同八九十年代说互联网一样让人费解，所以区块链的发展还处于幼儿时期，我们当然要牢牢抓住这个时期的机会去学习。小冷搜集了一些资料，和大家一起探索关于区块链有哪些需要熟悉的内容。 一 区块链理论基础 区块链基本原理和架构； 区块链发展阶段； 钱包的安装和使用,挖矿和矿池； 比特币/以太坊分叉的原理和案例； 拜占庭将军问题； 价值转移； 公有链,私有链,联盟链； UTXO ； Hash算法,merkle树； 共识协议Pow/Pos； 时间戳； 智能合约,dao组织； 软分叉/硬分叉； 以太坊,中心化和去中心化。 二 区块链数学基础,密码学和区块链常用算法 二进制基础和真随机数； hash运算和数字加密； 对称加密和非对称加密和数字签名； 高阶模操作； 指数和对数； 非对称加密算法原理解析； ASCII编码； Base64编码和Base58编码； Checksum； 比特币钱包和Vanity地址； 点对点网络的挑战； double speding问题； Ledger账本系统和UTXO方案； 挖矿和区块链形成； TestNet； BIP比特币优化协议和行业标准。 三 实现比特币 实现区块链生成； 实现挖矿与工作证明。 四 以太坊与智能区块链 区块链与以太坊,以太坊白皮书和黄皮书； 以太坊客户端安装和运行； 以太坊网络； 智能合约编程入门； solitidy变量,方法,继承和事件； oracle(先知)； solitidy编程实战； 以太坊前端框架web3.0； 以太坊+ipfs实现去中心化webapp。 五 IBM超级账本HyperLedger 超级账本介绍,区块链3.0； hyperledger febric架构； hyperledger febric集群平台搭建； hyperledger febric智能合约链码开发； hyperledger febric部署； hyperledger febric企业资产管理项目实战。 六 目标 掌握主流区块链(Bitcoin，Ethereum)相关机制与原理； 理解各类主流的共识算法(PoW，PoS，DPoS)； 熟练掌握区块链系统开发语言； 熟悉常见的安全协议和加密算法； 熟悉比特币优化协议和行业标准； 能基于以太坊编写智能合约； 能编写和发布代币； 能在风口鉴别区块链项目中的猪和鹰。 七 相关链接 知乎：如何学习区块链技术？ github：180天搞懂区块链 微信公众号：以太坊开发入门，完整入门 华章财经：一副漫画让你理解什么是区块链技术？ 持续更新…]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《2018开年第一天总结》]]></title>
    <url>%2F2018%2F02%2F23%2F%E3%80%8A2018%E5%BC%80%E5%B9%B4%E7%AC%AC%E4%B8%80%E5%A4%A9%E6%80%BB%E7%BB%93%E3%80%8B%2F</url>
    <content type="text"><![CDATA[开题 2017-2018这一年来感觉过的混混沌沌，完全失去的方向，甚至现在敲打键盘码字都觉得无法组织合适的语言。北漂的时间已经有2年半的时间了，中年危机越来越严重，尤其是看到以前跟自己同样起点的朋友，现在飞速的进步，对比下来觉得自己真的很惨但又无法克制的惰性一点点腐蚀着我以前的梦想，此时我觉得应该静下心来思考一下了。 回顾 我回顾这一年下来我都干了什么时候，脑海居然变的一片空白。依稀只记得前两天过年发生的事，身边朋友亲戚买车、买房、结婚之类的，都怀疑我自己是不是真的老了呢？突然就想起了毛不易的那句歌词来“怎么二十多年来，还在人海中浮沉…” 我就按照由近到远的时间线来回忆一下令我印象深刻的或事或技术等，至于为什么要这么做？一来是我觉得通过反省过去能检查以前走过的路是错的，以后避免再犯。二来是用这样的方法能站在局外人的角度来看我自己的人生发展以便更好的规划未来。 时间轴 2017年3月到8月这几个月来主要还是着眼公司APP的开发，其中遇到的最棘手的问题又以下几个，1.阿里云推送消息缓存到本地数据库，对数据库进行CURD的操作（数据库的迁移工作仍然做的不够完善） 2.对linkface 人脸识别和活体扫描的SDK的重新定制 3.登录过期或挤下线时候的页面更新 2017年6月往后有那么几个月每次下班回来都在玩手游，现在回想起来很幼稚又浪费了大量时间（该拖出去打一顿了）。恐怕普通人和优秀人之间的区别就在于下班时间该如何分配了吧，值得好好面壁思过！ 2017年8月开始研究如果搭建个人博客网站后来搭建完成，用shadowsockets来翻墙上网也是那段搞的。6个月下来写了17篇日志。量非常少，内容排版也有些粗糙，甚至到现在仍然没被百度收录（crying…）。但2017年唯一使我欣慰的也就是是lengzi.me这个博客网站了，以后继续努力做好更新工作。 2017年11月有那么几天我是一直在啃python，也花钱购买了教学视频，但是我自己都不知道为什么后来就没坚持下来后来就不了了之了。 2017年12月份初公司下达紧急通知，说要将APP从所有应用市场下架，那时候让我一度很方。虽然跟开发人员没多大关系，但觉得所有的成果没办法展示给用户时候感觉非常失望。 2017年12月7号同事介绍去进入币圈，结果一发不可收拾，币价上涨时候买的很欢，几乎花去了我大部分的积蓄，那时候我感觉自己找到了一条通往财富自由的路简直走火入魔了。虽然涨的很快，但跌的速度更让人也令人发指，水煮青蛙似的往下跌至到2018年1.6号，btc的价格从2万美金跌到了6千美金。那段时间我每天都在看盘（醒着和睡梦中），关注币价走势，越跌使握的意志变的愈加消沉，深套其中，觉得人生充满恶意。梦醒了发现，哪有躺着就能一夜暴富的好事，币价的走势影响着我的情绪、我的生活，我觉得自己变成了币圈操作的奴隶，是此生没有过的崩溃和绝望，照镜子发现自己面容憔悴老了许多岁。以此为鉴，抛弃一夜暴富的念头，没有比脚踏实地更正确的选择。 2018年1月份左右，因为领导安排合成公安部给的人脸识别和身份证NFC扫描SDK的任务，让我潜下来对SDK的开发有了初步的认识和了解，让我觉得受益匪浅。 2018年2月初，过年放假前的神游模式… 反省 1.那些功能点不完善，原因还是对技术的探索不够深入和彻底 2.对新语言和新技术的学习需要制定学习计划循序渐进 3.充分利用自由时间，不要沉溺手游了，否则可换来的是中年的奔波忙碌 4.抛弃一夜暴富的想法，脚踏实地的做事情 2018年目标 第一 四个月内完成区块链技术的学习 第二 Android开发进阶的学习 第三 微信公众号的开发]]></content>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Android studio下将library打包成jar并加密混淆》]]></title>
    <url>%2F2018%2F01%2F11%2F%E3%80%8AAndroid-studio%E4%B8%8B%E5%B0%86library%E6%89%93%E5%8C%85%E6%88%90jar%E5%B9%B6%E5%8A%A0%E5%AF%86%E6%B7%B7%E6%B7%86%E3%80%8B%2F</url>
    <content type="text"><![CDATA[开发过程中往往会引用到第三方的jar包或者library或者so文件，那么怎样将自己的一些文件打成jar包供别人使用或者自己使用呢，还有那些文件中的jar中可能会涉及到一些重要的接口和方法，又怎样混淆呢？今天小冷总结一下如何将library打包成jar包并做混淆处理 准备好自己将要打包的library下面图片中的library是我即将打包的library里面含有两个工具类文件 在mylibrary.gradle文件中做混淆打包的配置1234567891011121314151617def SDK_BASENAME = "myjar";def SDK_VERSION = "_v1.0.0";def sdkDestinationPath = "build/outputs/jar/";def zipFile = file('build/intermediates/bundles/release/classes.jar')task deleteBuild(type: Delete) &#123; delete sdkDestinationPath + SDK_BASENAME + SDK_VERSION + ".jar"&#125;task makeJar(type: Jar) &#123; from zipTree(zipFile) from fileTree(dir: 'src/main', includes: ['assets/**']) // 打包assets目录下的所有文件 baseName = SDK_BASENAME + SDK_VERSION destinationDir = file(sdkDestinationPath)&#125;makeJar.dependsOn(deleteBuild, build) 如下图： 在proguard-rules.pro文件中配置混淆文件 ###########################以下是AndroidStudio自带的混淆配置协议############################### # 表示混淆时不使用大小写混合类名 -dontusemixedcaseclassnames # 表示不跳过library中的非public的类 -dontskipnonpubliclibraryclasses # 打印混淆的详细信息 -verbose # Optimization is turned off by default. Dex does not like code run # through the ProGuard optimize and preverify steps (and performs some # of these optimizations on its own). -dontoptimize # 表示不进行校验,这个校验作用 在java平台上的 -dontpreverify # Note that if you want to enable optimization, you cannot just # include optimization flags in your own project configuration file; # instead you will need to point to the # "proguard-android-optimize.txt" file instead of this one from your # project.properties file. #使用注解需要添加 -keepattributes *Annotation* -keep public class com.google.vending.licensing.ILicensingService -keep public class com.android.vending.licensing.ILicensingService # For native methods, see http://proguard.sourceforge.net/manual/examples.html#native #指定不混淆所有的JNI方法 -keepclasseswithmembernames class * { native ; } # keep setters in Views so that animations can still work. # see http://proguard.sourceforge.net/manual/examples.html#beans #所有View的子类及其子类的get、set方法都不进行混淆 -keepclassmembers public class * extends android.view.View { void set*(***); *** get*(); } # We want to keep methods in Activity that could be used in the XML attribute onClick # 不混淆Activity中参数类型为View的所有方法 -keepclassmembers class * extends android.app.Activity { public void *(android.view.View); } # For enumeration classes, see http://proguard.sourceforge.net/manual/examples.html#enumerations # 不混淆Enum类型的指定方法 -keepclassmembers enum * { public static **[] values(); public static ** valueOf(java.lang.String); } # 不混淆Parcelable和它的子类，还有Creator成员变量 -keepclassmembers class * implements android.os.Parcelable { public static final android.os.Parcelable$Creator CREATOR; } # 不混淆R类里及其所有内部static类中的所有static变量字段 -keepclassmembers class **.R$* { public static ; } # The support library contains references to newer platform versions. # Don't warn about those in case this app is linking against an older # platform version. We know about them, and they are safe. # 不提示兼容库的错误警告 -dontwarn android.support.** # Understand the @Keep support annotation. -keep class android.support.annotation.Keep -keep @android.support.annotation.Keep class * {*;} -keepclasseswithmembers class * { @android.support.annotation.Keep ; } -keepclasseswithmembers class * { @android.support.annotation.Keep ; } -keepclasseswithmembers class * { @android.support.annotation.Keep (...); } ###########################以下是需要手动的混淆配置协议############################### -libraryjars "C:\Program Files\Java\jre1.8.0_151\lib\rt.jar" #-libraryjars "C:\Users\admin\AppData\Local\Android\sdk\platforms\android-26\android.jar" # 注意：以上两个路径需要将以上路径是自己jar包的位置，需要根据自己情况进行修改，如果报重复配置的错误，注释掉即可 #代码迭代优化的次数，默认5 -optimizationpasses 5 #混淆时不会产生形形色色的类名 -dontusemixedcaseclassnames #忽略警告 -ignorewarnings #以下是不需要混淆的文件 -keep class com.android.sdk.demo.LogUtils{ *; } -keep class com.android.sdk.demo.StorageUtils{ *; } 在Terminal命令窗口下输入打包命令：gradlew makeJar 直到下面生成BUILD SUCCESSFUL的提示就打包成功了。我刚开始在输入这个gradlew makeJar命令时候多次报 找不到 Tool.jar的错误，没办法我只能重装了一遍jdk（泪奔）然后顺利解决。最后就神奇在output文件夹下发现一个jar文件。如下图 引用自己的jar测试能不能用引用后发现系统已经将里面的参数做了混淆 如下图 小冷在打jar包时候，发现多次打了个空包。应该是全部都被混淆忽略掉了，此时需要留一个入口class文件不可混略。 github中的demo地址Android studio下将library打包成jar并加密混淆github中demo传送门]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>sdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中Bitmap和File、Base64String互转]]></title>
    <url>%2F2017%2F12%2F29%2FAndroid%E4%B8%ADBitmap%E5%92%8CFile%E3%80%81Base64String%E4%BA%92%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[一般在实际开发当中，会碰到将扫描生成的bitmap图片转为file保存到本地，也可能会碰到将本地的File图片转为base64String的格式上传提交给服务器 Bitmap转为File12345678910111213141516171819202122232425262728293031323334353637383940414243/** * @param mBitmap 图片的bitmap对象 * @param name 给图片文件取一个名字 */public void saveBitmapToFile(Bitmap mBitmap, String name) &#123; File file = new File(getCacheFile(this) + name); FileOutputStream fOut = null; try &#123; fOut = new FileOutputStream(file); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; mBitmap.compress(Bitmap.CompressFormat.JPEG, 100, fOut); try &#123; fOut.flush(); fOut.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;//获取缓存文件目录 public static File getCacheFile(Context context) &#123; File appCacheDir = null; if (Environment.MEDIA_MOUNTED .equals(Environment.getExternalStorageState()) &amp;&amp; hasExternalStoragePermission(context)) &#123; appCacheDir = getExternalCacheDir(context); &#125; if (appCacheDir == null) &#123; appCacheDir = context.getCacheDir(); &#125; if (appCacheDir == null) &#123; String cacheDirPath = "/data/data/" + context.getPackageName() + "/cache/"; appCacheDir = new File(cacheDirPath); if(appCacheDir.exists() == false)&#123; appCacheDir.mkdirs(); &#125; &#125; return appCacheDir; &#125; 此时在/data/data/文件夹下就会找到那种转换到本地的图片 将Bitmap转为Base64String12345678910111213141516171819202122232425262728293031323334/** * bitmap转为base64 * @param bitmap * @return */ public static String bitmapToBase64(Bitmap bitmap) &#123; String result = null; ByteArrayOutputStream baos = null; try &#123; if (bitmap != null) &#123; baos = new ByteArrayOutputStream(); bitmap.compress(Bitmap.CompressFormat.JPEG, 100, baos); baos.flush(); baos.close(); byte[] bitmapBytes = baos.toByteArray(); result = Base64.encodeToString(bitmapBytes, Base64.DEFAULT); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (baos != null) &#123; baos.flush(); baos.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return result; &#125;]]></content>
      <tags>
        <tag>Bitmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView的封装和优化]]></title>
    <url>%2F2017%2F11%2F15%2FRecyclerView%E7%9A%84%E5%B0%81%E8%A3%85%E5%92%8C%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Android的界面显示离不开RecyclerView，使用RecyclerView绕不开对其优化部分。冷子君介绍下自己使用，完整的优化RecyclerView优化封装流程和通用写法。使用RecyclerView之前需要在gradle文件添加’com.android.support:design:23.4.0’的包依赖demo直接在后面这个链接中：RecyclerView 封装和优化 xml部分1.activity_main.xml 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/activity_main" android:layout_width="match_parent" android:layout_height="match_parent" android:paddingBottom="@dimen/activity_vertical_margin" android:paddingLeft="@dimen/activity_horizontal_margin" android:paddingRight="@dimen/activity_horizontal_margin" android:paddingTop="@dimen/activity_vertical_margin" tools:context="com.android.recycleviewdemo.MainActivity"&gt; &lt;android.support.v7.widget.RecyclerView android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/rv_list"&gt; &lt;/android.support.v7.widget.RecyclerView&gt;&lt;/RelativeLayout&gt; 2.item.xml123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;TextView android:id="@+id/tv_title" android:layout_width="wrap_content" android:layout_height="40dp" android:gravity="center" android:layout_centerHorizontal="true" android:textColor="@color/font" android:textSize="@dimen/font_size" android:text="item"/&gt;&lt;/RelativeLayout&gt; 封装ViewHolder封装ViewHolder会使用到SparseArray 这个集合，使用它并不是提高显示效率而是为了节约内存。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class MyViewHolder extends RecyclerView.ViewHolder &#123; private SparseArray&lt;View&gt; mViews; private View mConvertView; private Context mContext; public MyViewHolder(Context context, View itemView) &#123; super(itemView); mContext = context; mConvertView = itemView; mViews = new SparseArray&lt;&gt;(); &#125; public static MyViewHolder createViewHolder(Context context, ViewGroup parent, int layoutId) &#123; View itemView = LayoutInflater.from(context).inflate(layoutId, parent, false); return new MyViewHolder(context, itemView); &#125; /** * 通过viewId获取控件 * * @param viewId * @return */ public &lt;T extends View&gt; T getView(int viewId) &#123; View view = mViews.get(viewId); if (view == null) &#123; view = mConvertView.findViewById(viewId); mViews.put(viewId, view); &#125; return (T) view; &#125; public View getConvertView() &#123; return mConvertView; &#125; /** * 设置TextView的值 * * @param viewId * @param text * @return */ public MyViewHolder setText(int viewId, String text) &#123; TextView tv = getView(viewId); tv.setText(text); return this; &#125; public MyViewHolder setChecked(int viewId, boolean isChecked) &#123; CheckBox tv = getView(viewId); tv.setChecked(isChecked); return this; &#125; public MyViewHolder setImageResource(int viewId, int resId) &#123; ImageView view = getView(viewId); view.setImageResource(resId); return this; &#125; public MyViewHolder setImageUrl(int viewId, String url) &#123; ImageView view = getView(viewId); return this; &#125; public MyViewHolder setImageUrlCommon(int viewId, String url) &#123; ImageView view = getView(viewId); return this; &#125; public MyViewHolder setImageBitmap(int viewId, Bitmap bitmap) &#123; ImageView view = getView(viewId); view.setImageBitmap(bitmap); return this; &#125; public MyViewHolder setImageDrawable(int viewId, Drawable drawable) &#123; ImageView view = getView(viewId); view.setImageDrawable(drawable); return this; &#125;&#125; 编写Adpter适配器部分RecyclerView是不支持点击点击事件的处理的，所以需要手动写1234567891011121314151617181920212223242526272829303132333435363738394041424344public class DemoAdpter extends RecyclerView.Adapter&lt;MyViewHolder&gt; &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); Context context; private OnItemClickLitener mOnItemClickLitener; public interface OnItemClickLitener &#123;void onItemClick(View view, int position);&#125; public void setOnItemClickLitener(OnItemClickLitener onItemClickLitener) &#123; mOnItemClickLitener = onItemClickLitener; &#125; public DemoAdpter(Context context) &#123; this.context = context; &#125; public void setData(List&lt;String&gt; list) &#123; this.list = list; notifyDataSetChanged(); &#125; @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; MyViewHolder viewHolder = MyViewHolder.createViewHolder(context, parent, R.layout.item); return viewHolder; &#125; @Override public void onBindViewHolder(MyViewHolder holder, final int position) &#123; holder.setText(R.id.tv_title, list.get(position)); holder.itemView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; mOnItemClickLitener.onItemClick(view,position); &#125; &#125;); &#125; @Override public int getItemCount() &#123; return list == null ? 0 : list.size(); &#125;&#125; Activity中使用并填充数据到界面12345678910111213141516171819202122232425262728293031323334353637383940public class MainActivity extends AppCompatActivity implements DemoAdpter.OnItemClickLitener &#123; private List&lt;String&gt; list = new ArrayList&lt;&gt;(); private RecyclerView mRv_list; private DemoAdpter mDemoAdpter = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initData(); &#125; private void initView() &#123; mRv_list = (RecyclerView) findViewById(R.id.rv_list); mDemoAdpter = new DemoAdpter(this); mRv_list.setAdapter(mDemoAdpter); mDemoAdpter.setOnItemClickLitener(this); LinearLayoutManager linearLayoutManager = new LinearLayoutManager(this); mRv_list.setLayoutManager(linearLayoutManager); &#125; private void initData() &#123; gainData(); &#125; private void gainData() &#123; for (int i = 0; i &lt; 50; i++) &#123; list.add(new String("item： " + i)); &#125; mDemoAdpter.setData(list); &#125; @Override public void onItemClick(View view, int position) &#123; Toast.makeText(this, list.get(position), Toast.LENGTH_SHORT).show(); &#125;&#125; 显示效果]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android下组件之间传递不同数据类型]]></title>
    <url>%2F2017%2F11%2F15%2FAndroid%E4%B8%8B%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E4%BC%A0%E9%80%92%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Android组件下传递数据是非常普遍而大量存在的，组件见可以分为以下几种类型：1.传递基本数据类型 2.传递对象 3.传递图片。下面介绍下冷子君在开发者当中使用到的传递数据的几种方式和写法。 传递基本数据类型 发送数据的组件 1234567public void jump(View v) &#123; Bundle bundle = new Bundle(); bundle.putString("key","1024"); Intent intent = new Intent(this,OtherActivity.class); intent.putExtras(bundle); startActivity(intent);&#125; 接受数据的组件 12345private void gaitData() &#123; Bundle bundle = getIntent().getExtras(); String key = bundle.getString("key"); tv.setText(key); &#125; 传递对象传递对象也比较常见。比如说在注册流程里面，整个流程不是在单独的一两个界面完成的，而是需要在多个页面来实现。这样就需要将需要传递的数据封装成对象。传递对象的方法有两种，一种是实现Serializable，另一种是实现Parcelable的方法。 结合Android Studio自带的插件可以方便的写出。下面介绍如果使用继承Parcelable的方式，来传递对象。 封装需要传递的对象 1.写出需要传递的bean类 123456public class Student &#123; private String name; private int age; private String sex; private String number;&#125; 2.利用ALT+Insert 快捷键并且选择 -Parcelable生成对应方法 1234567891011121314151617181920212223242526272829303132333435363738394041public class Student implements Parcelable &#123; private String name; private int age; private String sex; private String number; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(this.name); dest.writeInt(this.age); dest.writeString(this.sex); dest.writeString(this.number); &#125; public Student() &#123; &#125; protected Student(Parcel in) &#123; this.name = in.readString(); this.age = in.readInt(); this.sex = in.readString(); this.number = in.readString(); &#125; public static final Parcelable.Creator&lt;Student&gt; CREATOR = new Parcelable.Creator&lt;Student&gt;() &#123; @Override public Student createFromParcel(Parcel source) &#123; return new Student(source); &#125; @Override public Student[] newArray(int size) &#123; return new Student[size]; &#125; &#125;;&#125; 3.生成set和get方法来存取需要传递的数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class Student implements Parcelable &#123; private String name; private int age; private String sex; private String number; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getNumber() &#123; return number; &#125; public void setNumber(String number) &#123; this.number = number; &#125; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(this.name); dest.writeInt(this.age); dest.writeString(this.sex); dest.writeString(this.number); &#125; protected Student(Parcel in) &#123; this.name = in.readString(); this.age = in.readInt(); this.sex = in.readString(); this.number = in.readString(); &#125; public static final Parcelable.Creator&lt;Student&gt; CREATOR = new Parcelable.Creator&lt;Student&gt;() &#123; @Override public Student createFromParcel(Parcel source) &#123; return new Student(source); &#125; @Override public Student[] newArray(int size) &#123; return new Student[size]; &#125; &#125;;&#125; 发送数据的组件 12345678910111213public void jump(View v) &#123; Student stu = new Student(); stu.setName("冷子君"); stu.setAge(18); stu.setSex("男"); stu.setNumber("110120"); Bundle bundle = new Bundle(); bundle.putParcelable("key",stu); Intent intent = new Intent(this, OtherActivity.class); intent.putExtras(bundle); startActivity(intent);&#125; 获取数据的组件 1234567private void gaitData() &#123; Student stu = getIntent().getParcelableExtra("key"); mTv.setText(stu.getName()); mTv2.setText(stu.getAge()); mTv3.setText(stu.getNumber()); mTv4.setText(stu.getSex()); &#125; 传递图片应用中，可能牵涉到，需要将某界面中的一张或者多张图传递给下一个界面，并且最终提交给服务器或者保存到本地。此时就需要把bitmap对象在组件跟组件之间传递。如果之间传递bitmap对象可能造成内存溢出的问题，所以冷子君的做法是首先将图片保存到本地，拿到本地的file文件，实现最后的提交,最后将图片做删除或者加密处理。下面介绍如何将拍摄的照片缓存到本地。 1.保存bitmap到file文件 无论是某些扫描的sdk或者拍照，最后都可以转化为bitmap文件，只需要将bitmap保存到file文件就可以。1234567891011121314151617181920212223242526272829303132333435363738394041 /** * @param mBitmap 图片的bitmap对象 * @param name 给图片文件取一个名字 */public void saveBitmapToFile(Bitmap mBitmap,String name) &#123; File file = new File(getCacheFile(this) + name); FileOutputStream fOut = null; try &#123; fOut = new FileOutputStream(file); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; mBitmap.compress(Bitmap.CompressFormat.JPEG, 100, fOut); try &#123; fOut.flush(); fOut.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;//获取缓存文件目录public static File getCacheFile(Context context) &#123; File appCacheDir = null; if (Environment.MEDIA_MOUNTED .equals(Environment.getExternalStorageState()) &amp;&amp; hasExternalStoragePermission(context)) &#123; appCacheDir = getExternalCacheDir(context); &#125; if (appCacheDir == null) &#123; appCacheDir = context.getCacheDir(); &#125; if (appCacheDir == null) &#123; String cacheDirPath = "/data/data/" + context.getPackageName() + "/cache/"; appCacheDir = new File(cacheDirPath); if(appCacheDir.exists() == false)&#123; appCacheDir.mkdirs(); &#125; &#125; return appCacheDir;&#125; 2.取出缓存中的file文件的路径最后可以得到图片的路径并转成file对象，提交给服务器1String imageurl=getCacheFile(this) + name//name是图片的名字 小结传递不同数据类型多种多样，既可以通过intent传，也可以以eventbus，rxbus回调的方式的方式来传。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Python3-基础:字符串》]]></title>
    <url>%2F2017%2F11%2F03%2F%E3%80%8APython3-%E5%9F%BA%E7%A1%80-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%8B%2F</url>
    <content type="text"><![CDATA[Python中的字符串定义跟Java中定义有所不同，语言风格类似JavaScript和PHP。不需要定义字符串类型，创建时候也很简单只需要给变量分配一个值就可以了 例如：var2= “冷子君” 访问字符串中的值1234var1 = "hello world"var2= "冷子君"print(var1[0],var2[0])print(var1[0:5],var2[0:2]) 输出:h 冷 hello 冷子 Python字符串的更新12var1 = "hello world"print(var1[:6]+"冷子君") 输出:hello 冷子君 Python字符串的运算符下表实例变量a值为字符串 “Hello”，b变量值为 “Python”： 操作符 描述 实例 + 字符串连接 a + b 输出结果： HelloPython * 重复输出字符串 a*2 输出结果：HelloHello [] 通过索引获取字符串中字符 a[1] 输出结果 e [ : ] 截取字符串中的一部分 a[1:4] 输出结果 ell in 成员运算符 - 如果字符串中包含给定的字符返回 True H in a 输出结果 1 not in 成员运算符 - 如果字符串中不包含给定的字符返回 True M not in a 输出结果 1 r/R 原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母”r”（可以大小写）以外，与普通字符串有着几乎完全相同的语法。 print r’\n’ prints \n 和 print R’\n’ prints \n Python字符串格式化python字符串格式化符号: 符号 描述 %c 格式化字符及其ASCII码 %s 格式化字符串 %d 格式化整数 %u 格式化无符号整型 %o 格式化无符号八进制数 %x 格式化无符号十六进制数 %X 格式化无符号十六进制数（大写） %f 格式化浮点数字，可指定小数点后的精度 %e 用科学计数法格式化浮点数 %E 作用同%e，用科学计数法格式化浮点数 %g %f和%e的简写 %G %f 和 %E 的简写 %p 用十六进制数格式化变量的地址格式化操作符辅助指令: 123456789101112符号 功能* 定义宽度或者小数点精度- 用做左对齐+ 在正数前面显示加号( + )&lt;sp&gt; 在正数前面显示空格# 在八进制数前面显示零(&apos;0&apos;)，在十六进制前面显示&apos;0x&apos;或者&apos;0X&apos;(取决于用的是&apos;x&apos;还是&apos;X&apos;)0 显示的数字前面填充&apos;0&apos;而不是默认的空格% &apos;%%&apos;输出一个单一的&apos;%&apos;(var) 映射变量(字典参数)m.n. m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。 Python 的字符串内建函数 方法名 描述 capitalize() 将字符串的第一个字符转换为大写 center(width, fillchar) 返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。 count(str, beg= 0,end=len(string)) 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数 bytes.decode(encoding=”utf-8”, errors=”strict”) Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回 encode(encoding=’UTF-8’,errors=’strict’) 以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’ endswith(suffix, beg=0, end=len(string)) 检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False. expandtabs(tabsize=8) 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。 find(str, beg=0 end=len(string)) 检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1 index(str, beg=0, end=len(string)) 跟find()方法一样，只不过如果str不在字符串中会报一个异常. isalnum() 如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True,否则返回 False isalpha() 如果字符串至少有一个字符并且所有字符都是字母则返回 True, 否则返回 False isdigit() 如果字符串只包含数字则返回 True 否则返回 False.. islower() 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False isnumeric() 如果字符串中只包含数字字符，则返回 True，否则返回 False isspace() 如果字符串中只包含空白，则返回 True，否则返回 False istitle() 如果字符串是标题化的(见 title())则返回 True，否则返回 False isupper() 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False join(seq) 以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串 len(string) 返回字符串长度 ljust(width[, fillchar]) 返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。 lower() 转换字符串中所有大写字符为小写. lstrip() 截掉字符串左边的空格或指定字符。 maketrans() 创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。 max(str) 返回字符串 str 中最大的字母。 min(str) 返回字符串 str 中最小的字母。 replace(old, new [, max]) 把 将字符串中的 str1 替换成 str2,如果 max 指定，则替换不超过 max 次。 rfind(str, beg=0,end=len(string)) 类似于 find()函数，不过是从右边开始查找. rindex( str, beg=0, end=len(string)) 类似于 index()，不过是从右边开始. rjust(width,[, fillchar]) 返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串 rstrip() 删除字符串字符串末尾的空格. split(str=””, num=string.count(str)) num=string.count(str)) 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num 个子字符串 splitlines([keepends]) 按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。 startswith(str, beg=0,end=len(string)) 检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。 strip([chars]) 在字符串上执行 lstrip()和 rstrip() swapcase() 将字符串中大写转换为小写，小写转换为大写 title() 返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle()) translate(table, deletechars=””) 根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中 upper() 转换字符串中的小写字母为大写 zfill (width) 返回长度为 width 的字符串，原字符串右对齐，前面填充0 isdecimal() 检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Python3-基础:控制流》]]></title>
    <url>%2F2017%2F11%2F02%2F%E3%80%8APython3-%E5%9F%BA%E7%A1%80-%E6%8E%A7%E5%88%B6%E6%B5%81%E3%80%8B%2F</url>
    <content type="text"><![CDATA[稍微有编程经验的都知道，一个项目的代码是以控制流的方式来实现代码的编写的,Python3中的控制流跟java的相似，写法略有不同。下面介绍常用的控制流语句以及demo（摘自《a byte of Python》一书），在Python3中常用到的控制流语句包括： if 语句 while 循环 for 循环 break 语句 continue 语句 if 语句123456a=10b=20if(a==b): print("相等")else: print("不相等") 结果如下： 不相等 while 语句12345678910111213141516number =20;running = True;while running: guess=int(input(&apos;输入一个整数：&apos;)) if guess==number: print(&quot;恭喜你，猜中了&quot;) running = False elif guess &lt; number: print(&quot;猜的数字偏小&quot;) else: print(&quot;猜的数字偏大&quot;)else: print(&quot;循环结束&quot;)print(&quot;game over&quot;) 结果如下： 输入一个整数：10 猜的数字偏小 输入一个整数：30 猜的数字偏大 输入一个整数：25 猜的数字偏大 输入一个整数：24 猜的数字偏大 输入一个整数：20 恭喜你，猜中了 循环结束 game over for 循环1234for i in range(1,5): print(i)else: print(&quot;game over&quot;) 结果如下： 1 2 3 4 game over break 语句1234567while True: s=input(&quot;输入：&quot;) if s==&quot;exit&quot;: break print(&apos;字符串的长度&apos;,len(s))print(&quot;game over&quot;) 结果如下： 输入：python 字符串的长度 6 输入：java 字符串的长度 4 输入：exit game over continue 语句12345678while True: s=input(&quot;请输入：&quot;) if s==&quot;exit&quot;: break if len(s)&lt;5: print(&quot;太小&quot;) continue print(&quot;长度合适&quot;) 结果如下： 请输入：java 太小 请输入：python 长度合适 请输入：biancheng 长度合适 请输入：exit Process finished with exit code 0 小结Python的控制流跟Java的思想一致，写法略有不同，for循环差别最大。Python更简洁贴近“人的思维” Java跟接近机器语言。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Python3-基础:运算符》]]></title>
    <url>%2F2017%2F11%2F02%2F%E3%80%8APython3-%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%8B%2F</url>
    <content type="text"><![CDATA[下面列举几项常见的运算符,Python3的运算符包括 算术运算符 比较（关系）运算符 赋值运算符 逻辑运算符 位运算符 成员运算符 身份运算符 多行注释123456&apos;&apos;&apos;if(a==b): print(&quot;1-a等于b&quot;)else: print(&quot;1-a 不等于b&quot;)&apos;&apos;&apos; 123a = 10b = 20c = 0 赋值运算符1234c=a+bprint(&quot;c的值为：&quot;,c)c=a-bprint(&quot;c的值为：&quot;,c) c的值为: 30 c的值为: -10 逻辑运算符123456789if(a and b): print(&quot;result：&quot;,a)else: print(&quot;result：&quot;,b)if(a or b): print(&quot;result：&quot;,a)else: print(&quot;result：&quot;,b) result： 10 result: 10 成员运算符12345678910list = [1,2,3,4,5];if(a in list): print(&quot;result：&quot;,a)else: print(&quot;result：&quot;,b)if(a not in list): print(&quot;result：&quot;,a)else: print(&quot;result：&quot;,b) result: 20 result: 10 身份运算符1234567891011121314if(a is c): print(&quot;result：&quot;,a)else: print(&quot;result：&quot;,b)if(a is not b): print(&quot;result：&quot;,a)else: print(&quot;result：&quot;,b)if(id(a) is id(b)): print(&quot;result：&quot;,a)else: print(&quot;result：&quot;,b) result: 10 result: 10 result: 10]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[友盟多渠道打包]]></title>
    <url>%2F2017%2F11%2F01%2F%E5%8F%8B%E7%9B%9F%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[介绍 为了在友盟统计上面来观察不同应用市场下应用的下载量，需要根据不同的市场分发apk包。Eclipse IDE环境下逐一打包比较繁琐。相对Android Studio 进行区分打包对应的APK就容易的多,只需要几行代码就能搞定。 详解 配置build.gradle文件在build.gradle文件下的android{}节点内配置以下代码 123456789101112131415productFlavors &#123; huawei &#123;&#125; baidu &#123;&#125; tencent &#123;&#125; c360 &#123;&#125; oppo &#123;&#125; xiaomi &#123;&#125; zhenwo &#123;&#125; productFlavors.all &#123; flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name] &#125; &#125; 配置AndroidManifest.xml文件在AndroidManifest.xml文件下的application{}节点内配置以下代码 12&lt;meta-data android:value="xxxxxxxxxxxxcxxxxxx" android:name="UMENG_APPKEY"&gt;&lt;/meta-data&gt;&lt;meta-data android:name="UMENG_CHANNEL" android:value="$&#123;UMENG_CHANNEL_VALUE&#125;"&gt;&lt;/meta-data&gt; 打包签名Apk文件签名打包到APK文件时，只需要勾选自己所需要的渠道包就可以，因为需要打包多个APK包，编译的时间非常漫长，耐心等待即可。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>多渠道打包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈中Activity的管理]]></title>
    <url>%2F2017%2F10%2F17%2F%E6%A0%88%E4%B8%ADActivity%E7%9A%84%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[开启任务栈的模式有四种，包括standard、singleTop、singleTask、singleInstance，Activity会被保存到任务栈中，我们可能根据业务需求来关闭栈中的某一个或者多个Activity，下面总结出几种关于获取栈内Activity的几种方法 1.获取当前任务栈内前台正在运行的Activity123456789101112131415161718public static Activity getCurrentRunActivity(Context context) &#123; ActivityManager am = (ActivityManager) context.getSystemService(ACTIVITY_SERVICE); List&lt;ActivityManager.RunningTaskInfo&gt; cn = am.getRunningTasks(1); ActivityManager.RunningTaskInfo taskInfo=cn.get(0); ComponentName name=taskInfo.topActivity; Activity foregroundActivity = null; try &#123; foregroundActivity = (Activity) (Class.forName(name.getClassName()).newInstance()); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return foregroundActivity;&#125; 2.判断某一个Activity类在栈中是否存在任务栈中1234567891011121314151617private boolean isExsitMianActivity(Class&lt;?&gt; cls)&#123; Intent intent = new Intent(this, cls); ComponentName cmpName = intent.resolveActivity(getPackageManager()); boolean flag = false; if (cmpName != null) &#123; // 说明系统中存在这个activity ActivityManager am = (ActivityManager) getSystemService(ACTIVITY_SERVICE); List&lt;ActivityManager.RunningTaskInfo&gt; taskInfoList = am.getRunningTasks(10); for (ActivityManager.RunningTaskInfo taskInfo : taskInfoList) &#123; if (taskInfo.baseActivity.equals(cmpName)) &#123; // 说明它已经启动了 flag = true; break; //跳出循环，优化效率 &#125; &#125; &#125; return flag;&#125; 3.根据Activity获取当前Activity的类名1234public String getActivityName(Activity activity)&#123; String name = activity.getClass().getName(); return name; &#125; 4.清空任务栈中的activity并退出应用 android.os.Process.killProcess(android.os.Process.myPid());//后加 System.exit(0);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密算法]]></title>
    <url>%2F2017%2F10%2F09%2F%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[安卓中常见的加密是对密码的加密上传或者对图片的加密和解密本质上对io流过程中的字节进行混淆 MD5加密算法123456789101112131415161718192021222324252627public final static String getMD5(String s) &#123; char hexDigits[] = &#123;'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'&#125;; try &#123; byte[] btInput = s.getBytes(); // 获得MD5摘要算法的 MessageDigest 对象 MessageDigest mdInst = MessageDigest.getInstance("MD5"); // 使用指定的字节更新摘要 mdInst.update(btInput); // 获得密文 byte[] md = mdInst.digest(); // 把密文转换成十六进制的字符串形式 int j = md.length; char str[] = new char[j * 2]; int k = 0; for (int i = 0; i &lt; j; i++) &#123; byte byte0 = md[i]; str[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf]; str[k++] = hexDigits[byte0 &amp; 0xf]; &#125; return new String(str); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; AES加密算法1234567891011121314151617181920212223242526272829 public static void aesEncrypt(String decodePath,String encryptPath) &#123; try &#123; FileInputStream fis = null;// fis = new FileInputStream(StorageUtils.getCacheFile(this) + PHOTO_IDCARD_FRONT); fis = new FileInputStream(decodePath);// FileOutputStream fos = new FileOutputStream(StorageUtils.getCacheFile(this) + "testtest.jpg"); FileOutputStream fos = new FileOutputStream(encryptPath); //SecretKeySpec此类来根据一个字节数组构造一个 SecretKey SecretKeySpec sks = new SecretKeySpec(AES_KEY.getBytes(), "AES"); //Cipher类为加密和解密提供密码功能,获取实例 Cipher cipher = Cipher.getInstance("AES"); //初始化 cipher.init(Cipher.ENCRYPT_MODE, sks); //CipherOutputStream 为加密输出流 CipherOutputStream cos = new CipherOutputStream(fos, cipher); int b; byte[] d = new byte[1024]; while ((b = fis.read(d)) != -1) &#123; cos.write(d, 0, b); &#125; cos.flush(); cos.close(); fis.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; AES解密算法12345678910111213141516171819202122232425262728293031 public static void aesDecrypt(String path,String decodePath) &#123; try &#123; FileInputStream fis = null;// fis = new FileInputStream(StorageUtils.getCacheFile(this) + "test.jpg"); fis = new FileInputStream(path); ByteArrayOutputStream out = new ByteArrayOutputStream(1024); SecretKeySpec sks = new SecretKeySpec(AES_KEY.getBytes(), "AES"); Cipher cipher = Cipher.getInstance("AES"); cipher.init(Cipher.DECRYPT_MODE, sks); //CipherInputStream 为加密输入流 CipherInputStream cis = new CipherInputStream(fis, cipher); int b; byte[] d = new byte[1024]; while ((b = cis.read(d)) != -1) &#123; out.write(d, 0, b); &#125; out.flush(); out.close(); cis.close(); //获取字节流显示图片 byte[] bytes= out.toByteArray(); Bitmap bitmap = BitmapFactory.decodeByteArray(bytes, 0, bytes.length); saveBitmapToFile(bitmap,decodePath);//解密之后得到原图file &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; Hash算法123456789101112131415161718192021222324/** * 哈希算法 * */ public static String SHA1(String decript) &#123; try &#123; MessageDigest digest = java.security.MessageDigest.getInstance("SHA-1"); digest.update(decript.getBytes()); byte messageDigest[] = digest.digest(); StringBuffer hexString = new StringBuffer(); for (int i = 0; i &lt; messageDigest.length; i++) &#123; String shaHex = Integer.toHexString(messageDigest[i] &amp; 0xFF); if (shaHex.length() &lt; 2) &#123; hexString.append(0); &#125; hexString.append(shaHex); &#125; return hexString.toString(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; return ""; &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CheckboxView（开关控件）]]></title>
    <url>%2F2017%2F10%2F09%2FCheckboxView%EF%BC%88%E5%BC%80%E5%85%B3%E6%8E%A7%E4%BB%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[CheckboxView前言在开发过程中经常碰到开关控件view ，自定义控件相对复杂。使用简单的方式来实现跨越提高开发效率 layout布局设置123456&lt;CheckBox style="@style/CustomCheckboxTheme" android:id="@+id/cb_switch" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentRight="true" /&gt; style样式设置123&lt;style name="CustomCheckboxTheme" parent="@android:style/Widget.CompoundButton.CheckBox"&gt; &lt;item name="android:button"&gt;@drawable/checkbox_style&lt;/item&gt;&lt;/style&gt; checkbox_style开关图片选择器设置123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@mipmap/ic_manage_open" android:state_checked="true"/&gt; &lt;item android:drawable="@mipmap/ic_manage_close" android:state_checked="false"/&gt; &lt;item android:drawable="@mipmap/ic_manage_close"/&gt;&lt;/selector&gt; 小结和注意在改变了checkbox状态后，只是修改了内存的开关状态。finish当前页面checkbox的状态将重置]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《论怎样get√一项新技能》]]></title>
    <url>%2F2017%2F08%2F29%2F%E3%80%8A%E8%AE%BA%E6%80%8E%E6%A0%B7get%E4%B8%80%E9%A1%B9%E6%96%B0%E6%8A%80%E8%83%BD%E3%80%8B%2F</url>
    <content type="text"><![CDATA[前言 往往大多数人在了上学读书的那个时代，已经迷失了学习的方向，因为一切都被规划好了，按照老师的安排就够了。那时候我们按照老师的预习、写作业、背书，一切都是为了学了学或者是说为了大学而学，终于大学结束了。当步入社会的时候发现自己和社会格格不入，学习不仅仅局限于教科书式的学，没老师安排监督了，回头发现，还是搞不明白学习到底是什么到底怎样学习？是不是一个很可悲的故事呢。那么下面咱们就讨论一下我们到底怎么学习并掌握一项技能吧！ 正文 我觉得学习一项新技能需要循序渐进的经过以下三个过程: 是什么？ 怎么用？ 为什么？ 1$ 是什么？ “是什么？”这三个字看起来非常简单，而实际很多人都输在了这个起点搞不清是什么就去盲目的做了，比如说，我想建立一个自己域名的网站，那你得首先知道，域名是什么东西？网站是什么？网站有哪几部分构成？有什么属性？早以前有个同学费劲千辛万苦购买了一个域名告诉我说，他有自己了网站了，结果访问了之后404，虽然搞笑但实际上他只是买了个域名而已，不明白到底什么是网站。要想了解是什么？比如你要学Android 开发？你得知道安卓是什么？哦，它不是语言，不是手机，它是一个完整的独立的操作系统，就跟Window，MacOS，Linux一样的操作系统。 它能用来做什么呢？哦，基本的可以用他来做安卓手机的 App，也可以做车载系统应用开发，也可以做智能TV的应用的开发。再深入一点，你可以了解到全球有10多亿部Android移动设备和平板设备，尝试从各个角度去了解技能或技术，是不是对这项技术有更深的认识并且有想快速掌握它的冲动呢。 1$ 怎么用？ “怎么用？”是非常核心关键的一步，从上一步的了解这项技术或者语言“是什么？”也是为了“这么用？”而服务的。上一步了解了功能是什么，那就应该明白这项技能里面的我只需要掌握哪些功能、技能就够了，而不一定是全部，怎么用，说到底就是经验问题，你不可能凭空想象出来，要么你就是genius。经验这种东西获取的途径可以有多种多样，1.你可以问朋友，或者让朋友问他的朋友。2.生在这个幸运的互联网时代百度，谷歌【想科学上网请搜索关键词“搬瓦工”（vps服务器有国内镜像）、“shadowrocket”（客户端github）、“finalspeed”（加速器）】，YouTube等论坛可以解决70%以上的问题，当然你可以在各论坛里面直接截图把问题bug截图发给坛友，坐等红领巾回答。现在手把手教的视频太多了，照猫画虎的查看使用教程都没问题。3.有偿回答或者解决问题，有时候经验也是需要收费的，我曾经听一个博主说过，他无偿开源了自己的好多项目和技术知识，有次一个网友在群里面问他自己出现的问题该怎么解决，博主很忙没空去回答,然后网友就不高兴了骂骂咧咧，说“什么狗屁玩意儿”，对于这种类型的人也是存在的，人家凭什么把自己踩过的坑总结积累的经验无偿的告诉你呢？又不欠他什么，莫名其妙被骂。好的经验可以节约你大量的时间，如果通过金钱可以获取经验节约大量时间，有何不可呢？除非你觉得金钱比经验更重要。 1$ 为什么？ 了解了是什么和怎么用也就掌握了这项技能或语言的70%，很多人也会止步于此。觉得一切都还ok了，比如你在github上面clone了一份demo，在CSDN上面拷贝了一个方法，按照上面的方法修改了之。发现问题似乎是解决了，But！到此还不算真正的掌握这项技能。举个栗子，我在项目中集成了一个linkface++的人脸扫描模块的sdk，前期功能比较简单，只需要启动这个sdk进行人脸扫描就可以了，跟进sdk说明了解了是什么？应用场景？怎么配置？但到后期需求变更，产品经理要美化那个人脸扫描界面，并且还要自己控制扫描的开启和关闭，这时候就慌了，因为根本不了解这个启动扫描的过程经历了什么，调用了哪些方法？怎么调用的？所以，实际上如果碰到情况可能非常复杂，仅仅了解了是什么和怎么用的也是不够的，除非你一直在解决这些简单的问题，否则必须就得明白，从上面两步的“是什么？”和“为什么？”回复一下整个事件的来龙去脉了，具体在某一步骤？为什么要这样做呢？debug-debug，一步步走下去，最后一切都更明朗了，知道了“为什么？”可以自己提炼出来“怎么用？”技巧性的东西，不局限前人们的经验，最后发现自己也变成了一个有经验的前辈。了解了这些，遇到陌生的问题不会不知所措，知道问题的症结出在了哪里，又进一步强化“怎么用？” 。了解“是什么？”，明白“为什么？” 形成了良性循环，获取了get技能，更重要的是养成了一个解决实际问题的好习惯。 结语 如果你真的逐字逐字的读到这，那说明你的耐心非比寻常，啰嗦了那么多（呵呵~）。总言之,知道，“是什么？”“怎么用？”“为什么？” 前期是循序渐进，后期是分不开的，深刻体会才能理解更好掌握甚至精通。]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>讲道理</tag>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[针对Android下常用工具的单例封装]]></title>
    <url>%2F2017%2F08%2F28%2F%E9%92%88%E5%AF%B9Android%E4%B8%8B%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%9A%84%E5%8D%95%E4%BE%8B%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[单例模式单例优点不言而喻，它能够保证在整个类中，实际的实例化的对象只有一个，大大节约了内存资源，设计思路也非常简单：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）Java中常见的单例模式有两种“饿汉模式”和“懒汉模式”，不常见的就不说了。 饿汉模式 1234567891011public class Singleton &#123; private final static Singleton INSTANCE = new Singleton(); // Private constructor suppresses private Singleton() &#123;&#125; // default public constructor public static Singleton getInstance() &#123; return INSTANCE; &#125; &#125; 懒汉模式 1234567891011121314151617181920public class Singleton &#123; private static volatile Singleton INSTANCE = null; // Private constructor suppresses // default public constructor private Singleton() &#123;&#125; //thread safe and performance promote public static Singleton getInstance() &#123; if(INSTANCE == null)&#123; synchronized(Singleton.class)&#123; //when more than two threads run into the first null check same time, to avoid instanced more than one time, it needs to be checked again. if(INSTANCE == null)&#123; INSTANCE = new Singleton(); &#125; &#125; &#125; return INSTANCE; &#125; &#125; 实际在安卓项目中，手机内存比起旧式智能机大大增加，一般的封装模式是采用懒汉式，“用空间去换取时间”设计思路。 IntentIntent 作为activity和fragment传递简单数据的重要载体，写多了会发现代码冗余重复不如封装一个单例模式。 代码实例：123456789101112131415public class Intents &#123; private static Intents intents; public static Intents getIntents()&#123; if(intents == null) intents = new Intents(); return intents; &#125; public void Intent(Context context, Class&lt;?&gt; cs, Bundle bundle) &#123; Intent i = new Intent(context, cs); if (bundle != null) i.putExtras(bundle); context.startActivity(i); &#125;&#125; 使用方法： Bundle bundle = new Bundle(); bundle.putString("Message_Types", item.getFromUserName()); Intents.getIntents().Intent(this, LanchActivity.class, bundle); GsonGson作为Google官方的将json和model互相转换的工具也需要封装为一个单例模式,因为Gson gson = new Gson();会消耗大量资源，所以共享单例才是王道,封装起来也比较简单方便，看个人习惯。代码实例：123456789public class GsonUtil &#123; private static class GsonHolder&#123; private static final Gson INSTANCE = new Gson(); &#125; public static Gson getGsonInstance() &#123; return GsonHolder.INSTANCE; &#125;&#125; 使用方法： Model model = GsonUtil.getGsonInstance().fromJson(data, Model.class); AppActivityManager实际项目中要对activity进行统一销毁或者建立处理，需要创建一个单例模式要封装自己的activity管理工具。代码实例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119public class AppActivityManager &#123; private static Stack&lt;Activity&gt; activityStack = null; private static AppActivityManager screenManager = null; public static AppActivityManager getInstance() &#123; if (screenManager == null) &#123; screenManager = new AppActivityManager(); &#125; return screenManager; &#125; /** * 获得当前栈顶Activity * * @return */ public Activity currentActivity() &#123; if (activityStack == null) &#123; return null; &#125; if (!activityStack.listIterator().hasNext()) &#123; return null; &#125; Activity activity = activityStack.lastElement(); return activity; &#125; /** * 将当前Activity推入栈中 * * @param activity */ public void addActivity(Activity activity) &#123; if (activityStack == null) &#123; activityStack = new Stack&lt;Activity&gt;(); &#125; activityStack.add(activity); &#125; /** * 移除栈中的activity * * @param activity */ public void removeActivity(Activity activity) &#123; if (activityStack != null) activityStack.remove(activity); &#125; /** * 移除栈中的所有 activity */ public void removeAllActivity() &#123; if (activityStack != null) &#123; for (Activity activity : activityStack) &#123; activity.finish(); &#125; activityStack.clear(); &#125; &#125; /** * 退出栈顶Activity */ public void popActivity() &#123; if (activityStack != null &amp;&amp; activityStack.size() != 0) &#123; int size = activityStack.size(); Activity activity = activityStack.get(size - 1); activity.finish(); &#125; &#125; /** * 退出栈中所有Activity */ public void popAllActivity() &#123; if (activityStack == null) &#123; return; &#125; while (true) &#123; Activity activity = currentActivity(); if (activity == null) &#123; break; &#125; removeActivity(activity); &#125; &#125; /** * 返回到主界面 */ public void backMainActivity() &#123; if (activityStack == null) &#123; return; &#125; while (true) &#123; Activity activity = currentActivity(); if (getActivityCount() == 1) &#123; break; &#125; removeActivity(activity); &#125; &#125; /** * 获取栈中的activity个数 * * @return */ public int getActivityCount() &#123; if (activityStack == null) &#123; return -1; &#125; return activityStack.size(); &#125;&#125; 使用方法： 在自己的BaseActivity里面初始化添加 AppActivityManager.getInstance().addActivity(this); 销毁所有activity AppActivityManager.getInstance().removeAllActivity(); Perference少量数据无需保存到数据库，只需要用perference来保存各种类型的数据，单例封装必不可少。代码实例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class PerferenceUtils &#123; private static final String PERFERENCE_NAME="zhixin_phone"; private static SharedPreferences mSharedPreferences; private static PerferenceUtils preferenceUtils; private static SharedPreferences.Editor editor; private PerferenceUtils(Context context) &#123; mSharedPreferences = context.getSharedPreferences(PERFERENCE_NAME, Context.MODE_PRIVATE); editor = mSharedPreferences.edit(); &#125; public static synchronized void init(Context cxt) &#123; if (preferenceUtils == null) &#123; preferenceUtils = new PerferenceUtils(cxt); &#125; &#125; public synchronized static PerferenceUtils getInstance() &#123; if (preferenceUtils == null) &#123; throw new RuntimeException("please init first!"); &#125; return preferenceUtils; &#125; final public void putData(String key, String value) &#123; editor.putString(key, value).commit(); &#125; final public void putData(String key, int value) &#123; editor.putInt(key, value).commit(); &#125; final public void putData(String key, boolean value) &#123; editor.putBoolean(key, value).commit(); &#125; final public void putData(String key, float value) &#123; editor.putFloat(key, value).commit(); &#125; final public void putData(String key, long value) &#123; editor.putLong(key, value).commit(); &#125; final public String getData(String key, String defaultValue) &#123; return mSharedPreferences.getString(key, defaultValue); &#125; final public int getData(String key, int defaultValue) &#123; return mSharedPreferences.getInt(key, defaultValue); &#125; final public boolean getData(String key, boolean defaultValue) &#123; return mSharedPreferences.getBoolean(key, defaultValue); &#125; final public float getData(String key, float defaultValue) &#123; return mSharedPreferences.getFloat(key, defaultValue); &#125; final public long getData(String key, long defaultValue) &#123; return mSharedPreferences.getLong(key, defaultValue); &#125; final public void cleatData() &#123; editor.clear().commit(); &#125;&#125; 使用方法： 存： PerferenceUtils.getInstance().putData(LOGIN_STATUS, true); 取： PerferenceUtils.getInstance().getData(Constants.LOGIN_STATUS, false); AsyncHttpClient所有的http请求封装也是必需的，本质都是new httpClient或者new httpUrlClient，而新建这些网络资源会消耗大量内存资源，像流行的网络请求框架Retrofit，okhttp，volley等的封装原理上都要封装成为一个单例模式这里单封装下AsyncHttpClient。代码实例：123456789101112131415161718192021222324252627282930313233343536373839404142public class HttpTools &#123; private static AsyncHttpClient client = new AsyncHttpClient(true, 80, 443); public static AsyncHttpClient getClient() &#123; return client; &#125; static &#123; client.setTimeout(15000); &#125; public static RequestParams getParams() &#123; RequestParams params = new RequestParams(); return params; &#125; public static RequestHandle get(String url, ResponseHandlerInterface handler) &#123; return client.get(url, handler); &#125; public static RequestHandle get(String url, RequestParams params,ResponseHandlerInterface handler) &#123; return client.get(url, params, handler); &#125; public static RequestHandle post(String url, RequestParams params,ResponseHandlerInterface handler) &#123; // 下面三行代码是将token，username，deviceid分别添加到了header头部也可加到body体中 client.addHeader("token", PerferenceUtils.getInstance().getData(CUSTOMER_USER_TOKEN, "")); client.addHeader("username", PerferenceUtils.getInstance().getData(CUSTOMER_USER_PHONE, "")); client.addHeader("device_id", UserUtils.getDeviceId()); return client.post(url, params, handler); &#125; public static RequestHandle post(String url, ResponseHandlerInterface handler) &#123; return client.post(url, handler); &#125;&#125; 使用方法：12345678910111213141516171819RequestParams params = HttpTools.getParams(); try &#123; params.put("action", key); params.put("refresh", "true"); requestHandle = HttpTools.post(CUSTOMER_DEGREE_APPROVE, params, new AsyncHttpResponseHandler() &#123; @Override public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) &#123; &#125; @Override public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) &#123; &#125; &#125;); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>单例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[吾日三省]]></title>
    <url>%2F2017%2F08%2F10%2F%E5%90%BE%E6%97%A5%E4%B8%89%E7%9C%81%2F</url>
    <content type="text"><![CDATA[这个世界，在残酷惩罚不改变的人——北京地铁宣 先做重要的事我感觉这个道理人人都懂，但往往大部分人却做不好。举个栗子，我想把一张图贴到主页上面却发现…图片不是我想要的效果，可能是因为我有点小强迫症的原因，那我在github里面找一个软件run到手机上终于找到了这张图，修好之后发现图片有瑕疵，背景多了一个黑色边框，为了去掉这个边框，各种百度啊百度，发现Photoshop工具可以去掉，于是我又百度啊百度花了20分钟的时间终于下载并安装好了一个破解版ps工具，各种捣腾开始熟悉这个庞大的工具，熟悉完了后将图片放进去开始修黑边，但最后发现怎么都不是那么一回事，啊…炸了，炸了。最后还是放弃了在主页贴图的这件事。静下心来发现，最后什么都没做好，不仅如此啊，我还发现这件事就根本不重要，也不值得我花费那么多时间。我想了想，这一天应该怎样充分好时间，不让它偷偷溜走呢？我开始总结一下： 将一天要做的事罗列出来 将列出来的要做的事划分等级（非常重要、重要、一般、不重要） 如果某件事有困难先放起来，也记录下来，不要占用太多时间 如果觉得以上太机械，那就把所有未完成的事先记录下来标记未完成吧]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>讲道理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDownPad常用安装和语法]]></title>
    <url>%2F2017%2F08%2F04%2FMarkDownPad%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Win10安装MarkDownPad2.0折腾了半天终于可以愉快编写文档了，以前在win7上安装MarkDownPad没什么问题，在win10上安装时候会报错,具体错误如下图所示： 解决方案步骤： 安装Awesomium 1.6.6 SDK. 修改redegit](http://blog.csdn.net/chengjierui/article/details/53065599) 卸载后重新安装MarkDownPad MarkDown常用指令（持续更新）中英文行缩进 &amp;ensp; 半角的空格（英文） &amp;emsp; 全角的空格（中文） 字体颜色的设置1234567&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=6 face=&quot;黑体&quot;&gt;color=#0099ff size=10 face=&quot;黑体&quot;&lt;/font&gt;&lt;font color=#00ffff size=5&gt;color=#00ffff&lt;/font&gt;&lt;font color=gray size=6&gt;color=gray&lt;/font&gt;Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3 换行 两个空格+回车 用#标记符 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 用代码块:’’’1234567891011121314151617181920212223242526public final static String getMD5(String s) &#123; char hexDigits[] = &#123;'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'&#125;; try &#123; byte[] btInput = s.getBytes(); // 获得MD5摘要算法的 MessageDigest 对象 MessageDigest mdInst = MessageDigest.getInstance("MD5"); // 使用指定的字节更新摘要 mdInst.update(btInput); // 获得密文 byte[] md = mdInst.digest(); // 把密文转换成十六进制的字符串形式 int j = md.length; char str[] = new char[j * 2]; int k = 0; for (int i = 0; i &lt; j; i++) &#123; byte byte0 = md[i]; str[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf]; str[k++] = hexDigits[byte0 &amp; 0xf]; &#125; return new String(str); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDownPad</tag>
        <tag>MarkDown语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人简介]]></title>
    <url>%2F2017%2F08%2F04%2F%E4%B8%AA%E4%BA%BA%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[江湖经历从2015年来北京，从中关村到回龙观16年11月来公司已经有八个月时间了，浏览遍了github，csdn，android-bus从一个小小白，历练成了一个小小白菜，看了许多大神写的博文，建的自己的博客站点，深感佩服佩服，所以我也萌生了建站的想法。 我的性格人称浪里小黑龙，一朵梨花压海棠，人见人踩的逗比冷就是我! 人生箴言人生不止眼前的苟且，还有诗和远方。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>关于博主</tag>
        <tag>自我介绍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开篇-关于编写博文]]></title>
    <url>%2F2017%2F08%2F03%2F%E5%BC%80%E7%AF%87-%E5%85%B3%E4%BA%8E%E7%BC%96%E5%86%99%E5%8D%9A%E6%96%87%2F</url>
    <content type="text"><![CDATA[编写博客和建站并不紧紧是为了技（zhuang）术（bi），其实是对工作的一份敬畏。工作了几个月之后，就会发现有大量闲暇时间，如果对这些时间利用不好，就会觉得无聊，枯燥，感觉自己没有存在感实现不了自身的价值，我想不止是IT无论是哪一行干久了，都会有这样的感觉吧。所以，那就从写博文开始把总结分享给大家，把枯燥的工作变成有趣的事吧！建立自己的站点，花费了我差不多两天的时间，这里要感谢项志洪前辈，有了互联网大神们的无私奉献，才顺利了迈向了走进技术大门的第一步。我发现自从搭建完自己的站点后，爱“折腾”的精神也加强了，比如像怎样在”狗爹“上面购买域名（毕竟是新加坡的域名商，能用支付宝支付，好强，好赞）、hexo+github搭建博客、使用搬瓦工shadowsocket搭建vps翻墙（终于可以不做墙内人）、在dnspot域名服务商添加记录、做百度收录验证SEO优化、Atom工具的使用和安装插件等等，一点点的寻找到答案，小小成就感也在慢慢积累，我觉得过来人肯定是深有体会的，这可能就是写博文的意义所在。再次感谢开源的力量，感谢这个互联网时代的大神们。 推荐给大家知乎上一篇关于写博文意义的文章，《为什么要写博文》写的非常好，共勉。有了自己的博客站点也就有了一张真正意义的互联网身份证,更像是在自家后院里面种了一块园地（随便你做什么菜），如果想避免园地长满荒草，就得勤勤恳恳的劳动，而你需得乐此不疲。]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>开篇</tag>
        <tag>博文</tag>
      </tags>
  </entry>
</search>
